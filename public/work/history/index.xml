<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Historical Work on Tyson Chen — Executable Semantic Order</title>
    <link>http://localhost:1313/work/history/</link>
    <description>Recent content in Historical Work on Tyson Chen — Executable Semantic Order</description>
    <generator>Hugo -- 0.152.2</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 01 Jan 2020 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/work/history/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Censer</title>
      <link>http://localhost:1313/work/history/censer/</link>
      <pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/work/history/censer/</guid>
      <description>&lt;p&gt;Censer was an exploratory proposal for governing the deployment and execution of machine learning models under conditions of unclear legal liability.&lt;/p&gt;
&lt;p&gt;The project investigated how model execution could be made conditional, revocable, and compensable through institutional mechanisms. Central to the design was the concept of verifiable claims: explicit commitments about model behavior that could be challenged, falsified, and, if violated, trigger predefined consequences such as rollback, suspension, or compensation.&lt;/p&gt;
&lt;p&gt;Rather than constraining execution at the semantic or runtime level, Censer placed responsibility and enforcement within a governance and smart-contract framework. Deployment rights, auditing incentives, and insurance reserves were distributed among multiple stakeholders, reflecting an early attempt to externalize accountability for machine learning execution.&lt;/p&gt;</description>
    </item>
    <item>
      <title>SenseTW</title>
      <link>http://localhost:1313/work/history/sensetw/</link>
      <pubDate>Wed, 01 Nov 2017 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/work/history/sensetw/</guid>
      <description>&lt;p&gt;SenseTW was an open-source civic-tech project under the g0v community, aiming to build a long-term public-issue tracking and civic-participation platform.&lt;/p&gt;
&lt;p&gt;Rather than being a typical news site, the project emphasized persistent attention, structured issue mapping, ongoing commentary, and collaborative documentation — seeking to prevent critical social and political issues from fading once media focus moves on.&lt;/p&gt;
&lt;p&gt;The initiative explored how public awareness and communal memory could be sustained through digital infrastructure: by turning ephemeral discussions into persistent, structured, and shareable records.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Trustable AI (Augit)</title>
      <link>http://localhost:1313/work/history/trustableai/</link>
      <pubDate>Sat, 01 Jul 2017 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/work/history/trustableai/</guid>
      <description>&lt;p&gt;TrustableAI was an My first startup effort focused on operationalizing responsibility and risk controls in machine learning deployment pipelines.&lt;/p&gt;
&lt;p&gt;Through its product Augit, the company explored integrating fairness testing, dataset versioning, model documentation, compliance-oriented certification concepts, and early notions of AI insurance into a unified CI/CD workflow for machine learning systems. The objective was to determine whether deployment readiness could be assessed and enforced through engineering processes rather than ad-hoc review.&lt;/p&gt;</description>
    </item>
    <item>
      <title>ke-e</title>
      <link>http://localhost:1313/work/history/ke-e/</link>
      <pubDate>Sat, 03 Sep 2016 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/work/history/ke-e/</guid>
      <description>&lt;p&gt;ke-e was an experimental library exploring property-based and generative testing techniques, developed to systematically probe input spaces and structural assumptions in software systems.&lt;/p&gt;
&lt;p&gt;The project focused on generating constrained yet variable data in order to expose boundary conditions, invariant violations, and hidden failure modes. Testing was framed not as verification against expected outputs, but as falsification through structured perturbation.&lt;/p&gt;
&lt;p&gt;At the time, ke-e addressed practical concerns in testing and data robustness. In retrospect, it articulated an early infra-level intuition: meaningful testing requires mechanisms for systematically stressing structural commitments, even before those commitments are semantically articulated.&lt;/p&gt;</description>
    </item>
    <item>
      <title>ICLang</title>
      <link>http://localhost:1313/work/history/iclang/</link>
      <pubDate>Tue, 24 Feb 2015 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/work/history/iclang/</guid>
      <description>&lt;p&gt;ICLang was an early experimental system investigating coordination languages and process composition in distributed environments.&lt;/p&gt;
&lt;p&gt;The project explored whether heterogeneous processes could be composed and executed through explicit coordination structures, without requiring semantic interpretation of their internal logic. Each process was treated as a black box, constrained only by its input–output behavior and communication patterns.&lt;/p&gt;
&lt;p&gt;At the time, the system was motivated by practical questions around orchestration and service composition. In retrospect, it articulated an implicit structural intuition: execution order and behavioral constraints can be defined independently of understanding, intention, or interpretation.&lt;/p&gt;</description>
    </item>
    <item>
      <title>HyExec</title>
      <link>http://localhost:1313/work/history/hyexec/</link>
      <pubDate>Sun, 18 May 2014 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/work/history/hyexec/</guid>
      <description>&lt;p&gt;HyExec was an experimental system for wrapping Unix shell commands as fluent, composable objects in JavaScript.&lt;/p&gt;
&lt;p&gt;Rather than treating command execution as opaque strings or immediate side effects, HyExec exposed execution parameters—arguments, options, flags, ordering, and grouping—as manipulable structures prior to execution. Command invocation was deferred until explicitly triggered, allowing execution to be described, rewritten, and composed before occurrence.&lt;/p&gt;
&lt;p&gt;The project focused on separating execution description from execution itself. Fluent chaining and dynamic command grouping were used to express execution order as a first-class interface, independent of the underlying shell semantics.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kuansim</title>
      <link>http://localhost:1313/work/history/kuansim/</link>
      <pubDate>Tue, 30 Jul 2013 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/work/history/kuansim/</guid>
      <description>&lt;p&gt;Kuansim was a civic technology project initiated within the g0v community to address the persistence of public attention on social and political issues.&lt;/p&gt;
&lt;p&gt;Rather than competing with news media on immediacy or coverage, the platform was designed around follow-up as a first-class structure. Issues introduced on Kuansim were intentionally tracked over time, resisting the common pattern in which public discussion fades once mainstream attention shifts elsewhere.&lt;/p&gt;
&lt;p&gt;The project treated attention as a finite and fragile resource, requiring structural support to be sustained. By organizing commentary, ongoing updates, and solution-oriented discussion within a single platform, Kuansim explored how civic awareness could be made durable without assuming expert participation from users.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Harrow</title>
      <link>http://localhost:1313/work/history/harrow/</link>
      <pubDate>Sat, 04 May 2013 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/work/history/harrow/</guid>
      <description>&lt;p&gt;Harrow was an experimental implementation of Arrows as executable pipelines in Python, inspired by the Arrow abstraction in functional programming.&lt;/p&gt;
&lt;p&gt;The project treated execution not as isolated function calls, but as composable structures supporting forward and backward composition, branching, fan-in/fan-out, parallel execution, and looping. Execution order was expressed through formal combinators rather than implicit control flow.&lt;/p&gt;
&lt;p&gt;By modeling execution pipelines as Arrow compositions, Harrow made execution order itself a first-class, manipulable object. State propagation, feedback, and trace-like behaviors were represented structurally within the execution model.&lt;/p&gt;</description>
    </item>
    <item>
      <title>BoLiau</title>
      <link>http://localhost:1313/work/history/boliau/</link>
      <pubDate>Sat, 05 Jan 2013 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/work/history/boliau/</guid>
      <description>&lt;p&gt;BoLiau was an early experimental framework for task and mission orchestration, developed to manage chained operations and deferred execution in script-based environments.&lt;/p&gt;
&lt;p&gt;The system treated tasks as composable units, allowing workflows to be constructed through sequencing, continuation, and lazy execution. Individual tasks were considered operational black boxes, coordinated through explicit control structures rather than semantic interpretation.&lt;/p&gt;
&lt;p&gt;At the time, the project addressed practical needs around workflow automation and batch operations. In retrospect, it reflects an early engagement with process composition and execution ordering, without yet articulating semantic constraints or ontological commitments.&lt;/p&gt;</description>
    </item>
    <item>
      <title>VSGUI</title>
      <link>http://localhost:1313/work/history/vsgui/</link>
      <pubDate>Sun, 01 Aug 2010 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/work/history/vsgui/</guid>
      <description>&lt;p&gt;VSGUI was an early library for mediating human interaction with system execution through constrained graphical dialogs.&lt;/p&gt;
&lt;p&gt;Built on top of Zenity and UCLTIP, the project treated user input not as free-form text, but as structured, bounded signals—such as confirmations, file selections, password entries, and progress acknowledgements—suitable for direct integration into execution workflows.&lt;/p&gt;
&lt;p&gt;The library focused on reducing human interaction to a set of explicit input primitives that could be safely propagated into automated system execution. Human responses were constrained, typed, and failure-aware, allowing scripts to incorporate human-in-the-loop decisions without collapsing execution structure.&lt;/p&gt;</description>
    </item>
    <item>
      <title>UCLTIP</title>
      <link>http://localhost:1313/work/history/ucltip/</link>
      <pubDate>Thu, 29 Jul 2010 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/work/history/ucltip/</guid>
      <description>&lt;p&gt;UCLTIP was an early framework for treating command-line tools as structured, callable objects within Python.&lt;/p&gt;
&lt;p&gt;The project abstracted command execution away from raw shell strings, modeling commands, subcommands, options, pipelines, and execution modes as explicit programmatic constructs. Command invocation was configurable, inspectable, and composable prior to execution, allowing execution description to be separated from execution occurrence.&lt;/p&gt;
&lt;p&gt;UCLTIP consolidated earlier experiments in execution abstraction by providing a unified interface for command dispatching, option handling, error propagation, and pipeline composition. Execution order and data flow were made explicit through dedicated structures rather than implicit shell behavior.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LazyScripts</title>
      <link>http://localhost:1313/work/history/lazyscript/</link>
      <pubDate>Fri, 01 Jan 2010 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/work/history/lazyscript/</guid>
      <description>&lt;p&gt;LazyScripts was an early collection of automation scripts developed to externalize repetitive and error-prone system installation and configuration tasks, particularly in Ubuntu environments.&lt;/p&gt;
&lt;p&gt;Motivated by the practical difficulty of repeatedly reinstalling and configuring systems, the project focused on capturing hard-won execution knowledge in reusable scripts. The goal was not convenience, but durability: ensuring that once a correct setup had been achieved, it could be replayed, transferred, and reapplied without requiring the same human attention and error.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
